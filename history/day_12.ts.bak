import { run, Type } from "../day_utils"
const testData = `fs-end
he-DX
fs-he
start-DX
pj-DX
end-zg
zg-sl
zg-pj
pj-he
RW-he
fs-DX
pj-RW
zg-RW
start-pj
he-WI
zg-he
pj-fs
start-RW`

type Edge = {
    start: string,
    end: string
}

type Edges = Edge[]
type Graph = Map<string, Set<string>>

type Caves = Set<string>
type Path = string[]
type Visited = Map<string, number>
type NextCaveFilter = (name: string, currPath: Path) => boolean
function isBigCave(name: string): boolean {
    return name[0] === name[0].toUpperCase()
}

function filterPartOne(name: string, currPath: Path): boolean {
    return name !== "start" && (isBigCave(name) || currPath.find(it => it === name) === undefined)
}

function filterPartTwo(name: string, currPath: Path): boolean {
    if (name === "start") return false
    if (isBigCave(name)) return true
    let hasAlreadyVisitedTwice = false
    const visited = currPath
        .filter(it => !isBigCave(it))
        .reduce((existings, existingCave) => {
            if (!isBigCave(name) && existings.has(existingCave)) {
                hasAlreadyVisitedTwice = true;
            }
            return existings.add(existingCave)
        }, new Set<string>())
    return !visited.has(name) || !hasAlreadyVisitedTwice
}


function lookupPathes(currentCave: string, graph: Graph, currPath: Path, allPathes: Path[], filter: NextCaveFilter): Path[] {
    if (currentCave === 'end') {
        return allPathes.concat([currPath])
    }
    const nodes = graph.get(currentCave) ?? new Set<string>()
    return [...nodes.values()]
        .filter(name => filter(name, currPath))
        .reduce((pathes, nextCave) => lookupPathes(nextCave, graph, currPath.concat([nextCave]), pathes, filter), allPathes)
}

function puzzle(lines: string[]): void {
    const graph: Graph = new Map<string, Set<string>>()
    lines.map(line => line.split("-"))
        .forEach(parts => {
            if (!graph.has(parts[0])) {
                graph.set(parts[0], new Set<string>())
            }
            if (!graph.has(parts[1])) {
                graph.set(parts[1], new Set<string>())
            }
            graph.get(parts[0])?.add(parts[1])
            graph.get(parts[1])?.add(parts[0])
        })

    const pathsPartOne = lookupPathes("start", graph, ["start"], [], filterPartOne)
    console.log(`Result : ${pathsPartOne.length}`)

    const pathsPartTwo = lookupPathes("start", graph, ["start"], [], filterPartTwo)
    //pathsPartTwo.forEach(it => console.log(it))
    console.log(`Result : ${pathsPartTwo.length}`)
}

run(12, testData, [Type.TEST, Type.RUN], puzzle)
